# Verification Report

This Verification Report documents results on verification tests on both the GPIO and VGA Peripherals.

# GPIO

### <b> Formal Verification  </b>

- As specified before the GPIO is quite a simple peripheral thus most of its states can be tested using Formal Verification.
- The states that were tested using Formal Verification are as follows
    
    1. GPIO direction register stable (both input and output)
    2. GPIO direction register transition (both input to output and vice versa)
    3. GPIO data register write on both cases (input and output)
    4. Change of state only happens when control signals are valid

- Running JasperGold on showed a couple of errors on the GPIO which will be specified in the `Bugs Found` section at the bottom.

[Screenshot_Jasper]()

- The parity generation and parity checking was also checked using Formal Verification shown in the screenshot below

[Screenshot_Jasper]()

### <b> Unit Level Testing </b>

- Unit Level Testing on GPIO is done in the GPIO to mainly randomize the signal inputs to simulate invalid inputs into the GPIO.
- Whenever an invalid input is fed into the GPIO, the GPIO should drop the input packet and continue running as if it had not received an input.
- This has also been mixed with some valid inputs to further test the robustness of the GPIO peripheral

[Screenshot_Questa]()

[Screenshot_Score]()

- Functional Coverage bins were created to test how well the tests were covering the different functionalities of the GPIO. These bins are as follows:

    1. Writing to direction register
    2. Writing to data register
    3. Changing direction to output
    4. Changing direction to input
    5. Invalid input

The functional coverage report is shown below:

[Screenshot_functional]()

- The code coverage is also generated by QuestaSim in order to test how much of the peripheral is hit throughout the tests.

The code coverage report is shown below:

[Screenshot_code]()

### <b> Bugs Found </b>

Throughout both the Formal Verification tests and the Unit-level tests multiple bugs for the GPIO were found:

The bugs are listed as follows:

- HADDR inside the peripheral only takes the remaining 2 bits instead of the entire address
- The states of the last_* registers are only being updated when HREADY is high which causes weird behaviour when transitioning states.
- The internal registers are not being reset.

### <b> Bugs Fixed </b>

All the bugs listed above have been completely fixed.

# VGA

### <b> Formal Verification </b>

- VGA is a much more complex block in comparison to GPIO thus it is very difficult to verify much of the VGA block using Formal Verification.
- Formal Verification however was still used to attempt to test the different constraints listed in the specification such as:

    - Horizontal Front Porch
    - Horizontal Back Porch
    - Horizontal Sync Pulse
    - Total horizontal Pixels
    - Vertical Front Porch
    - Vertical Back Porch
    - Vertical Sync Pulse
    - Total vertical Pixels

- Although some tests converged, ultimately there are too many states that the VGA could be in thus we moved onto a different form of testing.

[Screenshot_Jasper]()

- As specified previously the Dual Lock Step is also tested using JasperGold and was verified properly as shown in the screenshot below

[Screenshot_Jasper]()

### <b> Unit Level Testing </b>

- It is very difficult to associate 1 singular input with 1 singular output in the VGA as an input corresponds to changing an entire frame in the VGA.

- Since 1 input into the VGA affects an entire frame inside the VGA it was decided that the VGA would be tested by comparing a sequence of inputs (up to a maximum of 900 since it is a 30x30 text region) to 1 frame output.

- This is done by generating the sequence of inputs beforehand and directly capturing the frame generated by the DUT and also the model and comparing between the two.

- Constrainted random testing were used to try to prove the robustness of the VGA under normal conditions and some directed testing was used to test edge cases of the VGA (for example a pixel on the bottom right of the screen). A list of the different functions used to do this is show [here (implement this)]().

- This was able to show a handful of VGA bugs that will be listed in the `Bugs Found` section for VGA.

- A screenshot of the score of the Unit-level test is shown below

[Unit_level]()

- An example of the monitor output for one of the tests (Full Frame) is shown below

[Full_Frame]()

### <b> Bugs Found </b>

The bugs are listed as follows:

- Counter not being reset
- Backspace not working properly
- Newline not working properly
- Last character of the previous line is repeated twice when the monitor goes to a new line.
- The contents inside the text region is shifted by 1 pixel to the right
- All the contents are shifted by 1 pixel. (both the text region and image region)

### <b> Bugs Fixed </b>

- The bugs fixed are the shifted 2 pixels. This however introduced a new bug in which all the lines are the correct behaviour apart from the first and last line. This causes failure in tests.

- Counter not being fed reset

- Backspace not being able to delete characters in previous rows

- Backspace not being able to delete characters in previous rows IF you are on the last line (this is a separate bug from the one above).

- Newline character incrementing the x index counter of the VGA which causes characters on a newline skipping 2 first 2 columns

- y position counter inside the VGA not being able to go back to the previous rows

- The last character of the previous line will be repeated twice when the monitor goes to a new line

# Integration Testing

- The results of the Integration testing showed that both the VGA and GPIO worked well together within an integrated system (the Cortex-M0 CPU).

- 3 different test types were performed on the integrated system, each having multiple subtests. These test types are as follows:

    - GPIO working by itself (without the VGA)
    - VGA working by itself (without the GPIO)
    - GPIO and VGA working at the same time

- To do this a multitude of assembly code instructions were generated and converted to hex.

### **Screenshots**

<u> GPIO solo </u>

[GPIO_solo](./Images/GPIO_solo.png)

<u> VGA solo </u>

[VGA_solo](./Images/VGA_solo.png)

<u> GPIO + VGA </u>

[GPIO_VGA_questa](./Images/GPIO_VGA_Questa.png)

[GPIO_VGA_monitor](./Images/GPIO_VGA_Monitor.png)
